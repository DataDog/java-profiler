plugins {
  id 'java'
  id 'java-library'
  id 'application'
}

repositories {
  mavenCentral()
}

// 1. Define paths and properties
def nativeSrcDir = file('src/test/cpp')
def jniHeadersDir = layout.buildDirectory.dir("generated/jni-headers").get().asFile
def outputLibDir = layout.buildDirectory.dir("libs/native").get().asFile
// Define the name of your JNI library (e.g., "ddproftest" becomes libddproftest.so/ddproftest.dll/libddproftest.dylib)
def libraryName = "ddproftest"

// Determine OS-specific file extensions and library names
def osName = org.gradle.internal.os.OperatingSystem.current()
def libFileExtension = (os().isMacOsX() ? "dylib" : "so")
def libraryFileName = "lib${libraryName}.${libFileExtension}"

// 2. Generate JNI headers using javac
tasks.named('compileJava') {
  // Tell javac to generate the JNI headers into the specified directory
  options.compilerArgs += ['-h', jniHeadersDir]
}

// 3. Define a task to compile the native code
tasks.register('buildNativeJniLibrary', Exec) {
  description 'Compiles the JNI C/C++ sources into a shared library'
  group 'build'

  // Ensure Java compilation (and thus header generation) happens first
  dependsOn tasks.named('compileJava')

  // Clean up previous build artifacts
  doFirst {
    outputLibDir.mkdirs()
  }

  // Assume GCC/Clang on Linux/macOS
  commandLine 'gcc'
  args "-I${System.getenv('JAVA_HOME')}/include" // Standard JNI includes
  if (os().isMacOsX()) {
    args "-I${System.getenv('JAVA_HOME')}/include/darwin" // macOS-specific includes
    args "-dynamiclib" // Build a dynamic library on macOS
  } else if (os().isLinux()) {
    args "-I${System.getenv('JAVA_HOME')}/include/linux" // Linux-specific includes
    args "-fPIC"
    args "-shared" // Build a shared library on Linux
  }
  args nativeSrcDir.listFiles()*.getAbsolutePath() // Source files
  args "-o", "${outputLibDir.absolutePath}/${libraryFileName}" // Output file path
}

apply from: rootProject.file('common.gradle')


def addCommonTestDependencies(Configuration configuration) {
  configuration.dependencies.add(project.dependencies.create('org.junit.jupiter:junit-jupiter-api:5.9.2'))
  configuration.dependencies.add(project.dependencies.create('org.junit.jupiter:junit-jupiter-engine:5.9.2'))
  configuration.dependencies.add(project.dependencies.create('org.junit.jupiter:junit-jupiter-params:5.9.2'))
  configuration.dependencies.add(project.dependencies.create('org.slf4j:slf4j-simple:1.7.32'))
  configuration.dependencies.add(project.dependencies.create('org.openjdk.jmc:flightrecorder:8.1.0'))
  configuration.dependencies.add(project.dependencies.create('org.openjdk.jol:jol-core:0.16'))
  configuration.dependencies.add(project.dependencies.create('org.junit-pioneer:junit-pioneer:1.9.1'))
  configuration.dependencies.add(project.dependencies.create('org.lz4:lz4-java:1.8.0'))
  configuration.dependencies.add(project.dependencies.create('org.xerial.snappy:snappy-java:1.1.10.1'))
  configuration.dependencies.add(project.dependencies.create('com.github.luben:zstd-jni:1.5.5-4'))
  configuration.dependencies.add(project.dependencies.create('org.ow2.asm:asm:9.6'))
  configuration.dependencies.add(project.dependencies.project(path: ":ddprof-test-tracer"))
}

def addCommonMainDependencies(Configuration configuration) {
  // Main dependencies for the unwinding validator application
  configuration.dependencies.add(project.dependencies.create('org.slf4j:slf4j-simple:1.7.32'))
  configuration.dependencies.add(project.dependencies.create('org.openjdk.jmc:flightrecorder:8.1.0'))
  configuration.dependencies.add(project.dependencies.create('org.openjdk.jol:jol-core:0.16'))
  configuration.dependencies.add(project.dependencies.create('org.lz4:lz4-java:1.8.0'))
  configuration.dependencies.add(project.dependencies.create('org.xerial.snappy:snappy-java:1.1.10.1'))
  configuration.dependencies.add(project.dependencies.create('com.github.luben:zstd-jni:1.5.5-4'))
  configuration.dependencies.add(project.dependencies.project(path: ":ddprof-test-tracer"))
}

configurations.create('testCommon') {
  canBeConsumed = true
  canBeResolved = true
}

// Configuration for main source set dependencies
configurations.create('mainCommon') {
  canBeConsumed = true
  canBeResolved = true
}

// Application configuration
application {
  mainClass = 'com.datadoghq.profiler.unwinding.UnwindingValidator'
}

buildConfigurations.each { config ->
  def name = config.name
  if (config.os != osIdentifier() || config.arch != archIdentifier()) {
    return
  }
  logger.debug("Creating configuration for ${name}")

  // Test configuration
  def cfg = configurations.create("test${name.capitalize()}Implementation") {
    canBeConsumed = true
    canBeResolved = true
    extendsFrom configurations.testCommon
  }
  addCommonTestDependencies(cfg)
  cfg.dependencies.add(project.dependencies.project(path: ":ddprof-lib", configuration: name))

  def task = tasks.register("test${name}", Test) {
    onlyIf {
      config.active
    }
    dependsOn compileTestJava
    description = "Runs the unit tests with the ${name} library variant"
    group = 'verification'
    // Filter classpath to include only necessary dependencies for this test task
    classpath = sourceSets.test.runtimeClasspath.filter { file ->
      !file.name.contains('ddprof-') || file.name.contains('test-tracer')
    } + cfg

    if (!config.testEnv.empty) {
      config.testEnv.each { key, value ->
        environment key, value
      }
      logger.debug("Setting environment variables for ${name}: ${config.testEnv}")
    }
    if (config.name == "asan") {
      onlyIf {
        locateLibasan() != null
      }
    } else if (config.name == "tsan") {
      onlyIf {
        locateLibtsan() != null
      }
    }
  }

  // Main/application configuration for unwinding validator (release and debug configs)
  if (name == "release" || name == "debug") {
    def mainCfg = configurations.create("${name}Implementation") {
      canBeConsumed = true
      canBeResolved = true
      extendsFrom configurations.mainCommon
    }
    addCommonMainDependencies(mainCfg)
    mainCfg.dependencies.add(project.dependencies.project(path: ":ddprof-lib", configuration: name))

    // Manual execution task
    tasks.register("runUnwindingValidator${name.capitalize()}", JavaExec) {
      onlyIf {
        config.active
      }
      dependsOn compileJava
      description = "Run the unwinding validator application (release or debug config)"
      group = 'application'
      mainClass = 'com.datadoghq.profiler.unwinding.UnwindingValidator'
      classpath = sourceSets.main.runtimeClasspath + mainCfg

      if (!config.testEnv.empty) {
        config.testEnv.each { key, value ->
          environment key, value
        }
      }

      def javaHome = System.getenv("JAVA_TEST_HOME")
      if (javaHome == null) {
        javaHome = System.getenv("JAVA_HOME")
      }
      executable = new File("${javaHome}", 'bin/java')

      jvmArgs '-Djdk.attach.allowAttachSelf', '-Djol.tryWithSudo=true',
        '-XX:ErrorFile=build/hs_err_pid%p.log', '-XX:+ResizeTLAB',
        '-Xmx512m'
    }

    // Configure arguments for runUnwindingValidator task
    tasks.named("runUnwindingValidator${name.capitalize()}") {
      if (project.hasProperty('validatorArgs')) {
        setArgs(project.property('validatorArgs').split(' ').toList())
      }
    }

    // CI reporting task
    tasks.register("unwindingReport${name.capitalize()}", JavaExec) {
      onlyIf {
        config.active
      }
      dependsOn compileJava
      description = "Generate unwinding report for CI (release or debug config)"
      group = 'verification'
      mainClass = 'com.datadoghq.profiler.unwinding.UnwindingValidator'
      classpath = sourceSets.main.runtimeClasspath + mainCfg
      args = [
        '--output-format=markdown',
        '--output-file=build/reports/unwinding-summary.md'
      ]

      if (!config.testEnv.empty) {
        config.testEnv.each { key, value ->
          environment key, value
        }
      }
      environment("CI", project.hasProperty("CI") || Boolean.parseBoolean(System.getenv("CI")))

      def javaHome = System.getenv("JAVA_TEST_HOME")
      if (javaHome == null) {
        javaHome = System.getenv("JAVA_HOME")
      }
      executable = new File("${javaHome}", 'bin/java')

      jvmArgs '-Djdk.attach.allowAttachSelf', '-Djol.tryWithSudo=true',
        '-XX:ErrorFile=build/hs_err_pid%p.log', '-XX:+ResizeTLAB',
        '-Xmx512m'

      doFirst {
        file("${buildDir}/reports").mkdirs()
      }
    }
  }
}

// Create convenience tasks that delegate to the appropriate config
task runUnwindingValidator {
  description = "Run the unwinding validator application (delegates to release if available, otherwise debug)"
  group = 'application'
  dependsOn {
    if (tasks.findByName('runUnwindingValidatorRelease')) {
      return 'runUnwindingValidatorRelease'
    } else if (tasks.findByName('runUnwindingValidatorDebug')) {
      return 'runUnwindingValidatorDebug'
    } else {
      throw new GradleException("No suitable build configuration available for unwinding validator")
    }
  }

  doLast {
    // Delegate to the appropriate task - actual work is done by dependency
  }
}

task unwindingReport {
  description = "Generate unwinding report for CI (delegates to release if available, otherwise debug)"
  group = 'verification'
  dependsOn {
    if (tasks.findByName('unwindingReportRelease')) {
      return 'unwindingReportRelease'
    } else if (tasks.findByName('unwindingReportDebug')) {
      return 'unwindingReportDebug'
    } else {
      throw new GradleException("No suitable build configuration available for unwinding report")
    }
  }

  doLast {
    // Delegate to the appropriate task - actual work is done by dependency
  }
}

tasks.withType(Test).configureEach {
  dependsOn tasks.named('buildNativeJniLibrary')

  // this is a shared configuration for all test tasks
  onlyIf {
    !project.hasProperty('skip-tests')
  }

  def config = it.name.replace("test", "")

  def keepRecordings = project.hasProperty("keepJFRs") || Boolean.parseBoolean(System.getenv("KEEP_JFRS"))
  environment("CI", project.hasProperty("CI") || Boolean.parseBoolean(System.getenv("CI")))

  // Base JVM arguments
  def jvmArgsList = [
    "-Dddprof_test.keep_jfrs=${keepRecordings}",
    '-Djdk.attach.allowAttachSelf',
    '-Djol.tryWithSudo=true',
    "-Dddprof_test.config=${config}",
    "-Dddprof_test.ci=${project.hasProperty('CI')}",
    "-Dddprof.disable_unsafe=true",
    '-XX:ErrorFile=build/hs_err_pid%p.log',
    '-XX:+ResizeTLAB',
    '-Xmx512m',
    '-XX:OnError=/tmp/do_stuff.sh',
    "-Djava.library.path=${outputLibDir.absolutePath}"
  ]

  // Enable Native Memory Tracking for leak detection tests
  // Use IgnoreUnrecognizedVMOptions to silently ignore on JVMs that don't support NMT
  jvmArgsList.add('-XX:+IgnoreUnrecognizedVMOptions')
  jvmArgsList.add('-XX:NativeMemoryTracking=detail')

  jvmArgs jvmArgsList

  def javaHome = System.getenv("JAVA_TEST_HOME")
  if (javaHome == null) {
    javaHome = System.getenv("JAVA_HOME")
  }
  useJUnitPlatform()
  executable = new File("${javaHome}", 'bin/java')

  testLogging {
    showStandardStreams = true
  }
}

test {
  onlyIf {
    false
  }
}

tasks.withType(JavaCompile).configureEach {
  options.compilerArgs.addAll(['--release', '8'])

  if (name == "compileTestJava") {
    sourceCompatibility = '8'
    targetCompatibility = '8'
  }
  classpath += configurations.testReleaseImplementation
}

// Make the assemble* tasks depend on the test* tasks
gradle.projectsEvaluated {
  buildConfigNames().each {
    def testTask = tasks.findByName("test${it}")
    def assembleTask = project(':ddprof-lib').tasks.findByName("assemble${it.capitalize()}")
    if (testTask && assembleTask) {
      assembleTask.dependsOn testTask
    }

    // Hook C++ gtest tasks to run as part of the corresponding Java test tasks
    def gtestTask = project(':ddprof-lib:gtest').tasks.findByName("gtest${it.capitalize()}")
    if (testTask && gtestTask) {
      testTask.dependsOn gtestTask
    }
  }
}

/*
 * Copyright 2026, Datadog, Inc.
 *
 * Gradle build file for libFuzzer-based fuzz testing.
 * This module compiles and runs fuzz targets against the profiler's C++ code
 * to discover bugs through automated input generation.
 *
 * Uses custom SimpleCppCompile/SimpleLinkExecutable tasks from buildSrc
 * to avoid Gradle cpp-application plugin's version parsing issues.
 */

// Note: cpp-application plugin removed - using SimpleCppCompile/SimpleLinkExecutable from buildSrc

// Access to common utilities and build configurations
if (rootDir.toString().endsWith("ddprof-lib/fuzz")) {
  apply from: rootProject.file('../../common.gradle')
  apply from: rootProject.file('../../gradle/configurations.gradle')
}

// Default fuzz duration in seconds (can be overridden with -Pfuzz-duration=N)
def fuzzDuration = project.hasProperty('fuzz-duration') ? project.getProperty('fuzz-duration').toInteger() : 60

// Directory for crash artifacts
def crashDir = file("${buildDir}/fuzz-crashes")

// Directory for seed corpus
def corpusDir = project(':ddprof-lib').file('src/test/fuzz/corpus')

// Helper to detect Homebrew LLVM on macOS
def findHomebrewLLVM() {
  if (!os().isMacOsX()) {
    return null
  }

  def possiblePaths = ["/opt/homebrew/opt/llvm", // Apple Silicon
    "/usr/local/opt/llvm"       // Intel Mac
  ]

  for (path in possiblePaths) {
    def llvmDir = file(path)
    if (llvmDir.exists() && file("${path}/bin/clang++").exists()) {
      logger.info("Found Homebrew LLVM at: ${path}")
      return path
    }
  }

  // Try using brew command
  try {
    def process = ["brew", "--prefix", "llvm"].execute()
    process.waitFor()
    if (process.exitValue() == 0) {
      def brewPath = process.in.text.trim()
      if (file("${brewPath}/bin/clang++").exists()) {
        logger.info("Found Homebrew LLVM via brew command at: ${brewPath}")
        return brewPath
      }
    }
  } catch (Exception e) {
    // brew not available or failed
  }

  return null
}

def homebrewLLVM = findHomebrewLLVM()

// Find the clang version directory within Homebrew LLVM
def findClangResourceDir(String llvmPath) {
  if (llvmPath == null) {
    return null
  }

  def clangLibDir = file("${llvmPath}/lib/clang")
  if (!clangLibDir.exists()) {
    return null
  }

  // Find the version directory (e.g., 18.1.8 or 19)
  def versions = clangLibDir.listFiles()?.findAll { it.isDirectory() }?.sort { a, b ->
    b.name <=> a.name  // Sort descending to get latest version
  }

  if (versions && versions.size() > 0) {
    def resourceDir = "${llvmPath}/lib/clang/${versions[0].name}"
    logger.info("Using clang resource directory: ${resourceDir}")
    return resourceDir
  }

  return null
}

def clangResourceDir = findClangResourceDir(homebrewLLVM)

// Helper to find fuzzer-capable clang++ (prefers Homebrew on macOS)
def findFuzzerCompiler(String llvmPath) {
  if (os().isMacOsX() && llvmPath != null) {
    return "${llvmPath}/bin/clang++"
  }
  // Fall back to standard compiler detection
  return CompilerUtils.findCxxCompiler()
}

def fuzzAll = tasks.register("fuzz") {
  onlyIf {
    hasFuzzer() && !project.hasProperty('skip-tests') && !project.hasProperty('skip-native') && !project.hasProperty('skip-fuzz')
  }
  group = 'verification'
  description = "Run all fuzz targets"

  if (!hasFuzzer()) {
    logger.warn("WARNING: libFuzzer not available - skipping fuzz tests (requires clang with -fsanitize=fuzzer)")
  }
}

// Register fuzz tasks using custom task types (replaces cpp-application plugin parasite pattern)
buildConfigurations.findAll { it.name == 'fuzzer' }.each { config ->
  if (config.os == osIdentifier() && config.arch == archIdentifier()) {
    // Use Homebrew clang on macOS for libFuzzer support, otherwise standard compiler
    def compiler = findFuzzerCompiler(homebrewLLVM)

    // Build include paths
    def includeFiles = files(
      project(':ddprof-lib').file('src/main/cpp'),
      "${javaHome()}/include",
      os().isMacOsX() ? "${javaHome()}/include/darwin" : "${javaHome()}/include/linux",
      project(':malloc-shim').file('src/main/public')
      )
    if (os().isMacOsX() && homebrewLLVM != null) {
      includeFiles = includeFiles + files("${homebrewLLVM}/include")
    }

    // Build compiler args - adapted from fuzzer config
    def fuzzCompilerArgs = config.compilerArgs.findAll {
      it != '-std=c++17' && it != '-DNDEBUG'
    } + ['-std=c++17', '-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION']
    if (os().isLinux() && isMusl()) {
      fuzzCompilerArgs = fuzzCompilerArgs + ['-D__musl__']
    }

    // Build linker args
    def fuzzLinkerArgs = config.linkerArgs.collect()

    // libFuzzer linking strategy:
    // On macOS with Homebrew LLVM, explicitly link the library file
    // because system clang looks in the wrong location
    if (os().isMacOsX() && clangResourceDir != null) {
      def fuzzerLib = "${clangResourceDir}/lib/darwin/libclang_rt.fuzzer_osx.a"
      if (file(fuzzerLib).exists()) {
        logger.info("Using Homebrew libFuzzer: ${fuzzerLib}")
        fuzzLinkerArgs.add(fuzzerLib)
        // Also link Homebrew's libc++ to match the fuzzer library's ABI
        fuzzLinkerArgs.add("-L${homebrewLLVM}/lib/c++")
        fuzzLinkerArgs.add("-lc++")
        fuzzLinkerArgs.add("-Wl,-rpath,${homebrewLLVM}/lib/c++")
      } else {
        logger.warn("Homebrew libFuzzer not found, falling back to -fsanitize=fuzzer")
        fuzzLinkerArgs.add("-fsanitize=fuzzer")
      }
    } else {
      // Standard libFuzzer linkage for Linux or when Homebrew not available
      fuzzLinkerArgs.add("-fsanitize=fuzzer")
    }
    fuzzLinkerArgs.addAll("-ldl", "-lpthread", "-lm")
    if (os().isLinux()) {
      fuzzLinkerArgs.add("-lrt")
    }

    def fuzzSrcDir = project(':ddprof-lib').file("src/test/fuzz/")
    if (fuzzSrcDir.exists()) {
      fuzzSrcDir.eachFile { fuzzFile ->
        if (fuzzFile.name.endsWith('.cpp')) {
          def fullName = fuzzFile.name.substring(0, fuzzFile.name.lastIndexOf('.'))
          // Strip "fuzz_" prefix from filename to get the target name
          def fuzzName = fullName.startsWith('fuzz_') ? fullName.substring(5) : fullName

          // Compile task
          def compileTask = tasks.register("compileFuzz_${fuzzName}", SimpleCppCompile) {
            onlyIf {
              config.active && hasFuzzer() && !project.hasProperty('skip-tests') && !project.hasProperty('skip-native') && !project.hasProperty('skip-fuzz')
            }
            group = 'build'
            description = "Compile the fuzz target ${fuzzName}"

            it.compiler = compiler
            it.compilerArgs = fuzzCompilerArgs.collect() // copy list
            // Compile main profiler sources (needed for fuzzing the actual code)
            sources = project(':ddprof-lib').fileTree('src/main/cpp') { include '**/*.cpp' } + files(fuzzFile)
            includes = includeFiles
            objectFileDir = file("$buildDir/obj/fuzz/${fuzzName}")
          }

          // Link task
          def binary = file("$buildDir/bin/fuzz/${fuzzName}/${fuzzName}")
          def linkTask = tasks.register("linkFuzz_${fuzzName}", SimpleLinkExecutable) {
            onlyIf {
              config.active && hasFuzzer() && !project.hasProperty('skip-tests') && !project.hasProperty('skip-native') && !project.hasProperty('skip-fuzz')
            }
            dependsOn compileTask
            group = 'build'
            description = "Link the fuzz target ${fuzzName}"

            linker = compiler
            linkerArgs = fuzzLinkerArgs.collect() // copy list
            objectFiles = fileTree("$buildDir/obj/fuzz/${fuzzName}") { include '*.o' }
            outputFile = binary
          }

          // Create corpus directory for this fuzz target
          def targetCorpusDir = file("${corpusDir}/${fuzzName}")

          // Execute task
          def executeTask = tasks.register("fuzz_${fuzzName}", Exec) {
            onlyIf {
              config.active && hasFuzzer() && !project.hasProperty('skip-tests') && !project.hasProperty('skip-native') && !project.hasProperty('skip-fuzz')
            }
            dependsOn linkTask
            group = 'verification'
            description = "Run the fuzz target ${fuzzName} for ${fuzzDuration} seconds"

            doFirst {
              // Ensure crash directory exists
              crashDir.mkdirs()
              // Ensure corpus directory exists (even if empty)
              targetCorpusDir.mkdirs()
            }

            executable binary
            // libFuzzer arguments:
            // - corpus directory (positional)
            // - max_total_time: stop after N seconds
            // - artifact_prefix: where to save crash files
            // - print_final_stats: show coverage stats at end
            args targetCorpusDir.absolutePath,
              "-max_total_time=${fuzzDuration}",
              "-artifact_prefix=${crashDir.absolutePath}/${fuzzName}-",
              "-print_final_stats=1"

            config.testEnv.each { key, value ->
              environment key, value
            }

            inputs.files binary
            // Fuzz tasks should run every time
            outputs.upToDateWhen { false }
          }

          fuzzAll.configure { dependsOn executeTask }
        }
      }
    }
  }
}

// Task to list available fuzz targets
tasks.register("listFuzzTargets") {
  group = 'help'
  description = "List all available fuzz targets"
  doLast {
    def fuzzSrcDir = project(':ddprof-lib').file("src/test/fuzz/")
    if (fuzzSrcDir.exists()) {
      println "Available fuzz targets:"
      fuzzSrcDir.eachFile { fuzzFile ->
        if (fuzzFile.name.endsWith('.cpp')) {
          def fullName = fuzzFile.name.substring(0, fuzzFile.name.lastIndexOf('.'))
          // Strip "fuzz_" prefix from filename to get the target name
          def fuzzName = fullName.startsWith('fuzz_') ? fullName.substring(5) : fullName
          println "  - fuzz_${fuzzName}"
        }
      }
      println ""
      println "Run individual targets with: ./gradlew :ddprof-lib:fuzz:fuzz_<name>"
      println "Run all targets with: ./gradlew :ddprof-lib:fuzz:fuzz"
      println "Configure duration with: -Pfuzz-duration=<seconds> (default: 60)"
    } else {
      println "No fuzz targets found. Create .cpp files in ddprof-lib/src/test/fuzz/"
    }
  }
}

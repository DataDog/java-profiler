plugins {
  id 'cpp-library'
  id 'java'
  id 'maven-publish'
  id 'signing'

  id 'com.github.ben-manes.versions' version '0.27.0'
  id 'de.undercouch.download' version '4.1.1'
}

// Helper function to check if objcopy is available
def checkObjcopyAvailable() {
  try {
    def process = ['objcopy', '--version'].execute()
    process.waitFor()
    return process.exitValue() == 0
  } catch (Exception e) {
    return false
  }
}

// Helper function to check if dsymutil is available (for macOS)
def checkDsymutilAvailable() {
  try {
    def process = ['dsymutil', '--version'].execute()
    process.waitFor()
    return process.exitValue() == 0
  } catch (Exception e) {
    return false
  }
}

// Helper function to check if debug extraction should be skipped
def shouldSkipDebugExtraction() {
  return project.hasProperty('skip-debug-extraction')
}

// Helper function to get debug file path for a given config
def getDebugFilePath(config) {
  def extension = os().isLinux() ? 'so' : 'dylib'
  return file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/debug/libjavaProfiler.${extension}.debug")
}

// Helper function to get stripped file path for a given config
def getStrippedFilePath(config) {
  def extension = os().isLinux() ? 'so' : 'dylib'
  return file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/stripped/libjavaProfiler.${extension}")
}

// Helper function to create error message for missing tools
def getMissingToolErrorMessage(toolName, installInstructions) {
  return """
    |${toolName} is not available but is required for split debug information.
    |
    |To fix this issue:
    |${installInstructions}
    |
    |If you want to build without split debug info, set -Pskip-debug-extraction=true
  """.stripMargin()
}

// Helper function to create debug extraction task
def createDebugExtractionTask(config, linkTask) {
  return tasks.register('extractDebugLibRelease', Exec) {
    onlyIf {
      config.active && !shouldSkipDebugExtraction()
    }
    dependsOn linkTask
    description = 'Extract debug symbols from release library'
    workingDir project.buildDir

    doFirst {
      def sourceFile = linkTask.get().linkedFile.get().asFile
      def debugFile = getDebugFilePath(config)

      // Check for required tools before proceeding
      if (os().isLinux()) {
        if (!checkObjcopyAvailable()) {
          def installInstructions = """
            |  - On Ubuntu/Debian: sudo apt-get install binutils
            |  - On RHEL/CentOS: sudo yum install binutils  
            |  - On Alpine: apk add binutils""".stripMargin()
          throw new GradleException(getMissingToolErrorMessage('objcopy', installInstructions))
        }
      } else if (os().isMacOsX()) {
        if (!checkDsymutilAvailable()) {
          def installInstructions = """
            |  dsymutil should be available with Xcode command line tools:
            |  xcode-select --install""".stripMargin()
          throw new GradleException(getMissingToolErrorMessage('dsymutil', installInstructions))
        }
      }

      // Ensure debug directory exists
      debugFile.parentFile.mkdirs()

      // Set the command line based on platform
      if (os().isLinux()) {
        commandLine = ['objcopy', '--only-keep-debug', sourceFile.absolutePath, debugFile.absolutePath]
      } else {
        // For macOS, we'll use dsymutil instead
        commandLine = ['dsymutil', sourceFile.absolutePath, '-o', debugFile.absolutePath.replace('.debug', '.dSYM')]
      }
    }
  }
}

// Helper function to create debug link task (Linux only)
def createDebugLinkTask(config, linkTask, extractDebugTask) {
  return tasks.register('addDebugLinkLibRelease', Exec) {
    onlyIf {
      config.active && os().isLinux() && !shouldSkipDebugExtraction()
    }
    dependsOn extractDebugTask
    description = 'Add debug link to the original library'

    doFirst {
      def sourceFile = linkTask.get().linkedFile.get().asFile
      def debugFile = getDebugFilePath(config)

      // Check for objcopy availability
      if (!checkObjcopyAvailable()) {
        def installInstructions = """
          |  - On Ubuntu/Debian: sudo apt-get install binutils
          |  - On RHEL/CentOS: sudo yum install binutils
          |  - On Alpine: apk add binutils""".stripMargin()
        throw new GradleException(getMissingToolErrorMessage('objcopy', installInstructions))
      }

      commandLine = ['objcopy', '--add-gnu-debuglink=' + debugFile.absolutePath, sourceFile.absolutePath]
    }
  }
}

// Helper function to create debug file copy task
def createDebugCopyTask(config, extractDebugTask) {
  return tasks.register('copyReleaseDebugFiles', Copy) {
    onlyIf {
      !shouldSkipDebugExtraction()
    }
    dependsOn extractDebugTask
    from file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/debug")
    into file(libraryTargetPath(config.name + '-debug'))
    include '**/*.debug'
    include '**/*.dSYM/**'
  }
}

// Main function to setup debug extraction for release builds
def setupDebugExtraction(config, linkTask) {
  if (config.name == 'release') {
    // Create all debug-related tasks
    def extractDebugTask = createDebugExtractionTask(config, linkTask)
    def addDebugLinkTask = createDebugLinkTask(config, linkTask, extractDebugTask)

    // Create the strip task and configure it properly
    def stripTask = tasks.register('stripLibRelease', StripSymbols) {
      onlyIf {
        config.active
      }
      dependsOn addDebugLinkTask
    }

    // Configure the strip task after registration
    stripTask.configure {
      targetPlatform = linkTask.get().targetPlatform
      toolChain = linkTask.get().toolChain
      binaryFile = linkTask.get().linkedFile.get().asFile
      outputFile = getStrippedFilePath(config)
    }

    def copyDebugTask = createDebugCopyTask(config, extractDebugTask)

    // Wire up the copy task to use stripped binaries
    def copyTask = tasks.findByName("copyReleaseLibs")
    if (copyTask != null) {
      copyTask.dependsOn stripTask
      copyTask.inputs.files stripTask.get().outputs.files
    }
  }
}

def libraryName = "ddprof"

description = "Datadog Java Profiler Library"

def component_version = project.hasProperty("ddprof_version") ? project.ddprof_version : project.version

def props = new Properties()
file("${rootDir}/gradle/ap-lock.properties").withInputStream { stream ->
  props.load(stream)
}

def branch_lock = props.getProperty("branch")
def commit_lock = props.getProperty("commit")

// this feels weird but it is the only way invoking `./gradlew :ddprof-lib:*` tasks will work
if (rootDir.toString().endsWith("ddprof-lib")) {
  apply from: rootProject.file('../common.gradle')
}

dependencies {
  if (os().isLinux()) {
    // the malloc shim works only on linux
    project(':malloc-shim')
  }
  project(':ddprof-lib:gtest')
}

// Add a task to run all benchmarks
tasks.register('runBenchmarks') {
  dependsOn ':ddprof-lib:benchmarks:runBenchmark'
  group = 'verification'
  description = 'Run all benchmarks'
}

test {
  onlyIf {
    !project.hasProperty('skip-tests')
  }
  useJUnitPlatform()
}

def libraryTargetBase(type) {
  return "${projectDir}/build/native/${type}"
}

def osarchext() {
  if (osIdentifier() == 'linux' && archIdentifier() != 'x64') {
    // when built on aarch64 the location the library is built in is 'x86-64' ¯\_(ツ)_/¯
    return "x86-64"
  } else if (osIdentifier() == 'macos') {
    return archIdentifier() == 'x64' ? 'x86-64' : 'arm64'
  } else {
    return archIdentifier()
  }
}

def libraryTargetPath(type) {
  return "${libraryTargetBase(type)}/META-INF/native-libs/${osIdentifier()}-${archIdentifier()}${isMusl() ? '-musl' : ''}"
}

def librarySourcePath(type, qualifier = "") {
  return "${projectDir}/build/lib/main/${type}/${osIdentifier()}/${archIdentifier()}/${qualifier}/libjavaProfiler.${osIdentifier() == 'macos' ? 'dylib' : 'so'}"
}

ext {
  libraryTargetBase = this.&libraryTargetBase
  libraryTargetPath = this.&libraryTargetPath
  librarySourcePath = this.&librarySourcePath
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

def isGitlabCI = System.getenv("GITLAB_CI") != null
def buildTempDir = "${projectDir}/build/tmp"

// Allow specifying the external location for the native libraries
// The libraries should be properly sorted into subfolders corresponding to the `libraryTargetPath` value for each
// os/arch/libc combination
tasks.register('copyExternalLibs', Copy) {
  if (project.hasProperty("with-libs")) {
    from(project.getProperty("with-libs")) {
      include "**/*.so"
      include "**/*.dylib"
    }
    into "${projectDir}/build/classes/java/main/META-INF/native-libs"
  }
}

def cloneAPTask = tasks.register('cloneAsyncProfiler') {
  description = 'Clones async-profiler repo if directory is missing or updates it if commit hash differs'
  inputs.file("${rootDir}/gradle/ap-lock.properties")
  doFirst {
    def targetDir = file("${projectDir}/build/async-profiler")
    if (!targetDir.exists()) {
      println "Cloning missing async-profiler git subdirectory..."
      exec {
        commandLine 'git', 'clone', '--branch', branch_lock, '--depth', '1', 'https://github.com/datadog/async-profiler.git', targetDir.absolutePath
      }
      exec {
        workingDir targetDir.absolutePath
        commandLine 'git', 'checkout', commit_lock
      }
    } else {
      def currentCommit = ""
      new ByteArrayOutputStream().withStream { os ->
        exec {
          workingDir targetDir.absolutePath
          commandLine 'git', 'rev-parse', 'HEAD'
          standardOutput = os
        }
        currentCommit = os.toString().trim()
      }

      if (currentCommit != commit_lock) {
        println "async-profiler commit hash differs (current: ${currentCommit}, expected: ${commit_lock}), updating..."
        exec {
          workingDir targetDir.absolutePath
          commandLine 'git', 'fetch', 'origin', branch_lock, '--depth', '1'
        }
        exec {
          workingDir targetDir.absolutePath
          commandLine 'git', 'checkout', commit_lock
        }
      } else {
        println "async-profiler git subdirectory present with correct commit hash."
      }
    }
  }
}

def copyUpstreamFiles = tasks.register('copyUpstreamFiles', Copy) {
  configure {
    dependsOn cloneAPTask
  }
  onlyIf {
    !project.hasProperty("debug-ap")
  }
  description = 'Copy shared upstream files'
  from("${projectDir}/build/async-profiler/src") {
    include "arch.h"
    include "incbin.h"
    include "mutex.h"
    include "mutex.cpp"
    include "stackWalker.h"
    include "stackWalker.cpp"
    include "stackFrame*.cpp"
    include "trap.h"
    include "trap.cpp"
    include "vmStructs.h"
    include "vmStructs.cpp"
  }
  into "${projectDir}/src/main/cpp-external"
}

def patchStackFrame = tasks.register("patchStackFrame") {
  description = 'Patch stackFrame_x64.cpp after copying'
  configure {
    dependsOn copyUpstreamFiles
  }
  doLast {
    def file = file("${projectDir}/src/main/cpp-external/stackFrame_x64.cpp")
    if (!file.exists()) throw new GradleException("File not found: ${file}")

    def content = file.getText('UTF-8')
    def original = content

    // Add no_sanitize to unwindStub
    content = content.replaceAll(
      /(bool\s+StackFrame::unwindStub\s*\()/,
      '__attribute__((no_sanitize("address"))) bool StackFrame::unwindStub('
      )

    // Replace *(unsigned int*)entry
    content = content.replaceAll(
      /entry\s*!=\s*NULL\s*&&\s*\*\(unsigned int\*\)\s*entry\s*==\s*0xec8b4855/,
      '''entry != NULL && ([&] { unsigned int val; memcpy(&val, entry, sizeof(val)); return val; }()) == 0xec8b4855'''
      )

    // Add no_sanitize to checkInterruptedSyscall
    content = content.replaceAll(
      /(bool\s+StackFrame::checkInterruptedSyscall\s*\()/,
      '__attribute__((no_sanitize("address"))) bool StackFrame::checkInterruptedSyscall('
      )

    // Replace *(int*)(pc - 6)
    content = content.replaceAll(
      /\*\(int\*\)\s*\(pc\s*-\s*6\)/,
      '([&] { int val; memcpy(&val, (const void*)(pc - 6), sizeof(val)); return val; }())'
      )

    // Insert #include <cstring> if missing
    if (!content.contains('#include <cstring>')) {
      def lines = content.readLines()
      def lastInclude = lines.findLastIndexOf { it.startsWith('#include') }
      if (lastInclude >= 0) lines.add(lastInclude + 1, '#include <cstring>')
      else lines.add(0, '#include <cstring>')
      content = lines.join('\n')
    }

    if (content != original) {
      file.write(content, 'UTF-8')
      println "Patched stackFrame_x64.cpp"
    }
  }
}

def patchStackWalker = tasks.register("patchStackWalker") {
  description = 'Patch stackWalker.cpp after copying'
  configure {
    dependsOn copyUpstreamFiles
  }
  doLast {
    def file = file("${projectDir}/src/main/cpp-external/stackWalker.cpp")
    if (!file.exists()) throw new GradleException("File not found: ${file}")

    def content = file.getText('UTF-8')
    def original = content

    // Add no_sanitize to walkVM
    content = content.replaceAll(
      /(int\s+StackWalker::walkVM\s*\()/,
      '__attribute__((no_sanitize("address"))) int StackWalker::walkVM('
      )

    if (content != original) {
      file.write(content, 'UTF-8')
      println "Patched stackWalker.cpp"
    }
  }
}

def initSubrepoTask = tasks.register('initSubrepo') {
  configure {
    dependsOn copyUpstreamFiles, patchStackFrame, patchStackWalker
  }
}

tasks.register('assembleAll') {}

// use the build config names to create configurations, copy lib and asemble jar tasks
buildConfigNames().each { name ->
  configurations.create(name) {
    canBeConsumed = true
    canBeResolved = false
    extendsFrom configurations.implementation    }

  def copyTask = tasks.register("copy${name.capitalize()}Libs", Copy) {
    from file(librarySourcePath(name, name == 'release' ? 'stripped' : '')).parent  // the release build is stripped
    into file(libraryTargetPath(name))

    if (name == 'release') {
      def stripTask = tasks.findByName('stripLibRelease')
      if (stripTask != null) {
        dependsOn stripTask
      }
    }
  }
  def assembleJarTask = tasks.register("assemble${name.capitalize()}Jar", Jar) {
    group = 'build'
    description = "Assemble the ${name} build of the library"
    dependsOn copyExternalLibs
    if (!project.hasProperty('skip-native')) {
      dependsOn copyTask
    }
    from sourceSets.main.output.classesDirs
    from files(libraryTargetBase(name)) {
      include "**/*"
    }
    archiveBaseName = libraryName
    archiveClassifier = name == 'release' ? '' : name // the release qualifier is empty
    archiveVersion = component_version
  }
  // We need this second level indirection such that we can make the assembling dependent on the tests
  // The catch is that the test tasks depend on the assembled jar so we need a wrapper assemble task instead
  def assembleTask = tasks.register("assemble${name.capitalize()}", Task) {
    dependsOn assembleJarTask
  }

  tasks.assembleAll.dependsOn assembleTask
}
configurations {
  // the 'all' configuration is used to aggregate all the build configurations
  assembled {
    canBeConsumed = true
    canBeResolved = false
    extendsFrom implementation
  }
}

// We need this trickery to reuse the toolchain and system config from tasks created by the cpp-library plugin
// Basically, we are listening when the default 'comile' and 'link' (eg. 'compileReleaseCpp') is added and then
// we are adding our own tasks for each build configuration, inheriting the part of the configuration which was
// added by the cpp-library plugin
tasks.whenTaskAdded { task ->
  if (task instanceof CppCompile) {
    if (!task.name.startsWith('compileLib') && task.name.contains('Release')) {
      buildConfigurations.each { config ->
        if (config.os == osIdentifier() && config.arch == archIdentifier()) {
          def cppTask = tasks.register("compileLib${config.name.capitalize()}", CppCompile) {
            onlyIf {
              config.active
            }
            group = 'build'
            description = "Compile the ${config.name} build of the library"
            objectFileDir = file("$buildDir/obj/main/${config.name}")
            compilerArgs.addAll(config.compilerArgs)
            if (os().isLinux() && isMusl()) {
              compilerArgs.add('-D__musl__')
            }
            toolChain = task.toolChain
            targetPlatform = task.targetPlatform
            includes task.includes
            includes project(':ddprof-lib').file('src/main/cpp-external').toString()
            includes project(':ddprof-lib').file('src/main/cpp').toString()
            includes "${javaHome()}/include"
            includes project(':malloc-shim').file('src/main/public').toString()
            if (os().isMacOsX()) {
              includes "${javaHome()}/include/darwin"
            } else if (os().isLinux()) {
              includes "${javaHome()}/include/linux"
            }
            systemIncludes.from task.systemIncludes
            source task.source
            inputs.files source
            outputs.dir objectFileDir
          }
          def linkTask = tasks.findByName("linkLib${config.name.capitalize()}".toString())
          if (linkTask != null) {
            linkTask.dependsOn cppTask
          }
        }
      }
    }
  } else if (task instanceof LinkSharedLibrary) {
    if (!task.name.startsWith('linkLib') && task.name.contains('Release')) {
      buildConfigurations.each { config ->
        if (config.os == osIdentifier() && config.arch == archIdentifier()) {
          def linkTask = tasks.register("linkLib${config.name.capitalize()}", LinkSharedLibrary) {
            onlyIf {
              config.active
            }
            group = 'build'
            description = "Link the ${config.name} build of the library"
            source = fileTree("$buildDir/obj/main/${config.name}")
            linkedFile = file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/libjavaProfiler.${os().isLinux() ? 'so' : 'dylib'}")
            def compileTask = tasks.findByName("compileLib${config.name.capitalize()}".toString())
            if (compileTask != null) {
              dependsOn compileTask
            }
            linkerArgs.addAll(config.linkerArgs)
            toolChain = task.toolChain
            targetPlatform = task.targetPlatform
            libs = task.libs
            inputs.files source
            outputs.file linkedFile
          }
          if (config.name == 'release') {
            setupDebugExtraction(config, linkTask)
          }
        }
      }
    }
  }
}

// configure the compiler here
tasks.withType(CppCompile).configureEach {
  if (name.startsWith('compileRelease') || name.startsWith('compileDebug')) {
    onlyIf {
      // disable the built-in compiler task for release; we are using the custom compiler task
      false
    }
  } else {
    onlyIf {
      !project.hasProperty('skip-native')
    }
  }
}

// configure linker
tasks.withType(LinkSharedLibrary).configureEach {
  if (name.startsWith('linkRelease') || name.startsWith('linkDebug')) {
    onlyIf {
      // disable the built-in linker task for release; we are using the custom linker task
      false
    }
  } else {
    onlyIf {
      !project.hasProperty('skip-native')
    }
  }
}

library {
  baseName = "javaProfiler"
  source.from file('src/main/cpp')
  source.from file('src/main/cpp-external')
  privateHeaders.from file('src/main/cpp')
  privateHeaders.from file('src/main/cpp-external')

  // aarch64 support is still incubating
  // for the time being an aarch64 linux machine will match 'machines.linux.x86_64'
  targetMachines = [machines.macOS, machines.linux.x86_64]
  linkage = [Linkage.SHARED]
}

tasks.withType(StripSymbols).configureEach {
  onlyIf {
    name == ("stripLibRelease") && !project.hasProperty('skip-native')
  }
}

jar.dependsOn copyExternalLibs

tasks.register('sourcesJar', Jar) {
  from sourceSets.main.allJava
  archiveBaseName = libraryName
  archiveClassifier = "sources"
  archiveVersion = component_version
}

tasks.register('javadocJar', Jar) {
  dependsOn javadoc
  archiveBaseName = libraryName
  archiveClassifier = 'javadoc'
  archiveVersion = component_version
  from javadoc.destinationDir
}

tasks.register('scanBuild', Exec) {
  workingDir "${projectDir}/src/test/make"
  commandLine 'scan-build'
  args "-o", "${projectDir}/build/reports/scan-build",
    "--force-analyze-debug-code",
    "--use-analyzer", "/usr/bin/clang++",
    "make", "-j4",  "clean", "all"
}

tasks.withType(Test) {
  onlyIf {
    !project.hasProperty('skip-tests')
  }
  def javaHome = System.getenv("JAVA_TEST_HOME")
  if (javaHome == null) {
    javaHome = System.getenv("JAVA_HOME")
  }
  executable = file("${javaHome}/bin/java")
  javaLauncher.set(javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(11)
  })
}

// relink the tasks when all are created
gradle.projectsEvaluated {
  buildConfigNames().each {
    def compileTask = tasks.findByName("compileLib${it.capitalize()}")
    def linkTask = tasks.findByName("linkLib${it.capitalize()}")
    if (linkTask != null) {
      if (it != 'release') {
        def copyTask = tasks.findByName("copy${it.capitalize()}Libs")
        if (copyTask != null) {
          copyTask.dependsOn linkTask
        }
      }
      def gtestTask = project(':ddprof-lib:gtest').tasks.findByName("gtest${it.capitalize()}")
      if (gtestTask != null) {
        linkTask.dependsOn gtestTask
      }
    }
    def javadocTask = tasks.findByName("javadoc")
    def copyReleaseLibs = tasks.findByName("copyReleaseLibs")
    if (javadocTask != null && copyReleaseLibs != null) {
      javadocTask.dependsOn copyReleaseLibs
    }
    def initTask = tasks.findByName("initSubrepo")
    if (initTask != null) {
      compileTask.dependsOn initTask
    }
  }
}

artifacts {
  // create artifacts for all configures build config names
  buildConfigNames().each {
    def task = tasks.named("assemble${it.capitalize()}Jar")
    artifacts.add('assembled', task)
    artifacts.add(it, task)
  }
}

publishing {
  publications {
    assembled(MavenPublication) { publication ->
      buildConfigNames().each {
        publication.artifact tasks.named("assemble${it.capitalize()}Jar")
      }
      publication.artifact sourcesJar
      publication.artifact javadocJar

      publication.groupId = 'com.datadoghq'
      publication.artifactId = 'ddprof'
    }
  }
}

tasks.withType(GenerateMavenPom).configureEach {
  doFirst {
    MavenPom pom = it.pom
    pom.name = project.name
    pom.description = "${project.description} (${component_version})"
    pom.packaging = "jar"
    pom.url = "https://github.com/datadog/java-profiler"
    pom.licenses {
      license {
        name = "The Apache Software License, Version 2.0"
        url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
        distribution = "repo"
      }
    }
    pom.scm {
      connection = "scm:https://datadog@github.com/datadog/java-profiler"
      developerConnection = "scm:git@github.com:datadog/java-profiler"
      url = "https://github.com/datadog/java-profiler"
    }
    pom.developers {
      developer {
        id = "datadog"
        name = "Datadog"
      }
    }
  }
}

signing {
  useInMemoryPgpKeys(System.getenv("GPG_PRIVATE_KEY"), System.getenv("GPG_PASSWORD"))
  sign publishing.publications.assembled
}

tasks.withType(Sign).configureEach {
  // Only sign in Gitlab CI
  onlyIf { isGitlabCI || (System.getenv("GPG_PRIVATE_KEY") != null && System.getenv("GPG_PASSWORD") != null) }
}

/**
 * State assertions below...
 */

gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
  if (taskGraph.hasTask(publish) || taskGraph.hasTask("publishToSonatype")) {
    assert project.findProperty("removeJarVersionNumbers") != true
    if (taskGraph.hasTask("publishToSonatype")) {
      assert System.getenv("SONATYPE_USERNAME") != null
      assert System.getenv("SONATYPE_PASSWORD") != null
      if (isCI) {
        assert System.getenv("GPG_PRIVATE_KEY") != null
        assert System.getenv("GPG_PASSWORD") != null
      }
    }
  }
}

afterEvaluate {
  assert description: "Project $project.path is published, must have a description"
}

// we are publishing very customized artifacts - we are attaching the native library to the resulting JAR artifact
tasks.withType(AbstractPublishToMaven).configureEach {
  if (it.name.contains('AssembledPublication')) {
    it.dependsOn assembleReleaseJar
  }
  rootProject.subprojects {
    mustRunAfter tasks.matching { it instanceof VerificationTask }
  }
}

clean {
  delete "${projectDir}/src/main/cpp-external"
}
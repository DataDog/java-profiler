plugins {
  id 'java'
  id 'maven-publish'
  id 'signing'

  id 'com.github.ben-manes.versions' version '0.27.0'
  id 'de.undercouch.download' version '4.1.1'
}

// Import custom native build task types from buildSrc
// These replace the problematic cpp-library plugin which has version detection issues

// Helper function to check if objcopy is available
def checkObjcopyAvailable() {
  try {
    def process = ['objcopy', '--version'].execute()
    process.waitFor()
    return process.exitValue() == 0
  } catch (Exception e) {
    return false
  }
}

// Helper function to check if dsymutil is available (for macOS)
def checkDsymutilAvailable() {
  try {
    def process = ['dsymutil', '--version'].execute()
    process.waitFor()
    return process.exitValue() == 0
  } catch (Exception e) {
    return false
  }
}

// Helper function to check if debug extraction should be skipped
def shouldSkipDebugExtraction() {
  // Skip if explicitly disabled
  if (project.hasProperty('skip-debug-extraction')) {
    return true
  }

  // Skip if required tools are not available
  if (os().isLinux() && !checkObjcopyAvailable()) {
    return true
  }

  if (os().isMacOsX() && !checkDsymutilAvailable()) {
    return true
  }

  return false
}

// Helper function to get debug file path for a given config
def getDebugFilePath(config) {
  def extension = os().isLinux() ? 'so' : 'dylib'
  return file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/debug/libjavaProfiler.${extension}.debug")
}

// Helper function to get stripped file path for a given config
def getStrippedFilePath(config) {
  def extension = os().isLinux() ? 'so' : 'dylib'
  return file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/stripped/libjavaProfiler.${extension}")
}

// Helper function to create error message for missing tools
def getMissingToolErrorMessage(toolName, installInstructions) {
  return """
    |${toolName} is not available but is required for split debug information.
    |
    |To fix this issue:
    |${installInstructions}
    |
    |If you want to build without split debug info, set -Pskip-debug-extraction=true
  """.stripMargin()
}

// Helper function to create debug extraction task
def createDebugExtractionTask(config, linkTask) {
  return tasks.register("extractDebugLib${config.name.capitalize()}", Exec) {
    onlyIf {
      !shouldSkipDebugExtraction()
    }
    dependsOn linkTask
    description = 'Extract debug symbols from release library'
    workingDir project.buildDir

    // Declare outputs so Gradle knows what files this task creates
    outputs.file getDebugFilePath(config)

    doFirst {
      def sourceFile = linkTask.get().outputFile
      def debugFile = getDebugFilePath(config)

      // Ensure debug directory exists
      debugFile.parentFile.mkdirs()

      // Set the command line based on platform
      if (os().isLinux()) {
        commandLine = ['objcopy', '--only-keep-debug', sourceFile.absolutePath, debugFile.absolutePath]
      } else {
        // For macOS, we'll use dsymutil instead
        commandLine = ['dsymutil', sourceFile.absolutePath, '-o', debugFile.absolutePath.replace('.debug', '.dSYM')]
      }
    }
  }
}

// Helper function to create debug link task (Linux only)
def createDebugLinkTask(config, linkTask, extractDebugTask) {
  return tasks.register("addDebugLinkLib${config.name.capitalize()}", Exec) {
    onlyIf {
      os().isLinux() && !shouldSkipDebugExtraction()
    }
    dependsOn extractDebugTask
    description = 'Add debug link to the original library'

    inputs.files linkTask, extractDebugTask
    outputs.file { linkTask.get().outputFile }

    doFirst {
      def sourceFile = linkTask.get().outputFile
      def debugFile = getDebugFilePath(config)

      commandLine = ['objcopy', '--add-gnu-debuglink=' + debugFile.absolutePath, sourceFile.absolutePath]
    }
  }
}

// Helper function to create debug file copy task
def createDebugCopyTask(config, extractDebugTask) {
  return tasks.register("copy${config.name.capitalize()}DebugFiles", Copy) {
    onlyIf {
      !shouldSkipDebugExtraction()
    }
    dependsOn extractDebugTask
    from file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/debug")
    into file(libraryTargetPath(config.name))
    include '**/*.debug'
    include '**/*.dSYM/**'
  }
}

// Main function to setup debug extraction for release builds
def setupDebugExtraction(config, linkTask) {
  if (config.name == 'release' && config.active && !project.hasProperty('skip-native')) {
    // Create all debug-related tasks
    def extractDebugTask = createDebugExtractionTask(config, linkTask)
    def addDebugLinkTask = createDebugLinkTask(config, linkTask, extractDebugTask)

    // Create a simple strip task using Exec instead of the cpp-library's StripSymbols
    def stripTask = tasks.register('stripLibRelease', Exec) {
      dependsOn addDebugLinkTask
      onlyIf { !shouldSkipDebugExtraction() }

      def strippedFile = getStrippedFilePath(config)
      outputs.file strippedFile

      doFirst {
        strippedFile.parentFile.mkdirs()
        def sourceFile = linkTask.get().outputFile

        if (os().isLinux()) {
          // Linux: use strip to create a stripped copy
          commandLine 'cp', sourceFile.absolutePath, strippedFile.absolutePath
        } else {
          // macOS: use strip -S to strip debug symbols
          commandLine 'cp', sourceFile.absolutePath, strippedFile.absolutePath
        }
      }

      doLast {
        def strippedFilePath = strippedFile.absolutePath
        if (os().isLinux()) {
          exec { commandLine 'strip', '--strip-debug', strippedFilePath }
        } else {
          exec { commandLine 'strip', '-S', strippedFilePath }
        }
      }
    }

    def copyDebugTask = createDebugCopyTask(config, extractDebugTask)

    // Wire up the copy task to use stripped binaries
    def copyTask = tasks.findByName("copyReleaseLibs")
    if (copyTask != null) {
      copyTask.dependsOn stripTask
      copyTask.inputs.files stripTask.get().outputs.files

      // Create an extra folder for the debug symbols
      copyTask.dependsOn copyDebugTask
    }
  }
}

def libraryName = "ddprof"

description = "Datadog Java Profiler Library"

def component_version = project.hasProperty("ddprof_version") ? project.ddprof_version : project.version

// this feels weird but it is the only way invoking `./gradlew :ddprof-lib:*` tasks will work
if (rootDir.toString().endsWith("ddprof-lib")) {
  apply from: rootProject.file('../common.gradle')
}

dependencies {
  if (os().isLinux()) {
    // the malloc shim works only on linux
    project(':malloc-shim')
  }
  project(':ddprof-lib:gtest')
}

// Add a task to run all benchmarks
tasks.register('runBenchmarks') {
  dependsOn ':ddprof-lib:benchmarks:runBenchmark'
  group = 'verification'
  description = 'Run all benchmarks'
}

test {
  onlyIf {
    !project.hasProperty('skip-tests')
  }
  useJUnitPlatform()
}

def libraryTargetBase(type) {
  return "${projectDir}/build/native/${type}"
}

def osarchext() {
  if (osIdentifier() == 'linux' && archIdentifier() != 'x64') {
    // when built on aarch64 the location the library is built in is 'x86-64' ¯\_(ツ)_/¯
    return "x86-64"
  } else if (osIdentifier() == 'macos') {
    return archIdentifier() == 'x64' ? 'x86-64' : 'arm64'
  } else {
    return archIdentifier()
  }
}

def libraryTargetPath(type) {
  return "${libraryTargetBase(type)}/META-INF/native-libs/${osIdentifier()}-${archIdentifier()}${isMusl() ? '-musl' : ''}"
}

def librarySourcePath(type, qualifier = "") {
  return "${projectDir}/build/lib/main/${type}/${osIdentifier()}/${archIdentifier()}/${qualifier}/libjavaProfiler.${osIdentifier() == 'macos' ? 'dylib' : 'so'}"
}

ext {
  libraryTargetBase = this.&libraryTargetBase
  libraryTargetPath = this.&libraryTargetPath
  librarySourcePath = this.&librarySourcePath
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

// Configure Java 9+ source set for multi-release JAR
sourceSets {
  java9 {
    java {
      srcDirs = ['src/main/java9']
    }
  }
}

def current = JavaVersion.current().majorVersion.toInteger()
def requested = current >= 11 ? current : 11

// Configure Java 9 compilation with Java 11 toolchain
tasks.named('compileJava9Java') {
  javaCompiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(requested)
  }
  options.release = 9

  // Add main source set output to classpath
  classpath = sourceSets.main.output + configurations.compileClasspath
  dependsOn tasks.named('compileJava')
}

def isGitlabCI = System.getenv("GITLAB_CI") != null
def buildTempDir = "${projectDir}/build/tmp"

// Allow specifying the external location for the native libraries
// The libraries should be properly sorted into subfolders corresponding to the `libraryTargetPath` value for each
// os/arch/libc combination
tasks.register('copyExternalLibs', Copy) {
  if (project.hasProperty("with-libs")) {
    from(project.getProperty("with-libs")) {
      include "**/*.so"
      include "**/*.dylib"
      include "**/*.debug"
      include "**/*.dSYM/**"
    }
    into "${projectDir}/build/classes/java/main/META-INF/native-libs"
  }
}

tasks.register('assembleAll') {}

// use the build config names to create configurations, copy lib and asemble jar tasks
buildConfigNames().each { name ->
  configurations.create(name) {
    canBeConsumed = true
    canBeResolved = false
    extendsFrom configurations.implementation    }

  def copyTask = tasks.register("copy${name.capitalize()}Libs", Copy) {
    from file(librarySourcePath(name, name == 'release' ? 'stripped' : '')).parent  // the release build is stripped
    into file(libraryTargetPath(name))

    if (name == 'release') {
      def stripTask = tasks.findByName('stripLibRelease')
      if (stripTask != null) {
        dependsOn stripTask
      }
    }
  }
  def assembleJarTask = tasks.register("assemble${name.capitalize()}Jar", Jar) {
    group = 'build'
    description = "Assemble the ${name} build of the library"
    dependsOn copyExternalLibs
    dependsOn tasks.named('compileJava9Java')
    if (!project.hasProperty('skip-native')) {
      dependsOn copyTask
    }

    if (name == 'debug') {
      manifest {
        attributes 'Premain-Class': 'com.datadoghq.profiler.Main'
      }
    }

    from sourceSets.main.output.classesDirs
    from sourceSets.java9.output.classesDirs
    from files(libraryTargetBase(name)) {
      include "**/*"
    }
    archiveBaseName = libraryName
    archiveClassifier = name == 'release' ? '' : name // the release qualifier is empty
    archiveVersion = component_version
  }
  // We need this second level indirection such that we can make the assembling dependent on the tests
  // The catch is that the test tasks depend on the assembled jar so we need a wrapper assemble task instead
  def assembleTask = tasks.register("assemble${name.capitalize()}", Task) {
    dependsOn assembleJarTask
  }

  tasks.assembleAll.dependsOn assembleTask
}
configurations {
  // the 'all' configuration is used to aggregate all the build configurations
  assembled {
    canBeConsumed = true
    canBeResolved = false
    extendsFrom implementation
  }
}

// Register native compilation and linking tasks using simple custom task types
// This replaces the cpp-library plugin's parasite pattern that was prone to
// toolchain detection failures with newer compiler versions
buildConfigurations.each { config ->
  if (config.os == osIdentifier() && config.arch == archIdentifier()) {
    // Determine compiler - prefer clang++ if available
    def compiler = CompilerUtils.findCxxCompiler()
    def libExtension = os().isMacOsX() ? 'dylib' : 'so'

    // Build include paths
    def includeFiles = files(
      project(':ddprof-lib').file('src/main/cpp'),
      "${javaHome()}/include",
      os().isMacOsX() ? "${javaHome()}/include/darwin" : "${javaHome()}/include/linux",
      project(':malloc-shim').file('src/main/public')
      )

    // Compile task
    def cppTask = tasks.register("compileLib${config.name.capitalize()}", SimpleCppCompile) {
      onlyIf {
        config.active && !project.hasProperty('skip-native')
      }
      group = 'build'
      description = "Compile the ${config.name} build of the library"

      it.compiler = compiler
      it.compilerArgs = config.compilerArgs.collect() // copy list
      if (os().isLinux() && isMusl()) {
        it.compilerArgs.add('-D__musl__')
      }
      sources = fileTree(project(':ddprof-lib').file('src/main/cpp')) { include '**/*.cpp' }
      includes = includeFiles
      objectFileDir = file("$buildDir/obj/main/${config.name}")
    }

    // Link task
    def linkTask = tasks.register("linkLib${config.name.capitalize()}", SimpleLinkShared) {
      onlyIf {
        config.active && !project.hasProperty('skip-native')
      }
      dependsOn cppTask
      group = 'build'
      description = "Link the ${config.name} build of the library"

      linker = compiler
      linkerArgs = config.linkerArgs.collect() // copy list
      objectFiles = fileTree("$buildDir/obj/main/${config.name}") { include '*.o' }
      outputFile = file("$buildDir/lib/main/${config.name}/${osIdentifier()}/${archIdentifier()}/libjavaProfiler.${libExtension}")
    }

    // Setup debug extraction for release builds
    if (config.name == 'release') {
      setupDebugExtraction(config, linkTask)
    }
  }
}

// Note: cpp-library plugin removed - using SimpleCppCompile/SimpleLinkShared from buildSrc instead
// This eliminates toolchain version detection issues with newer gcc/clang versions

jar {
  dependsOn copyExternalLibs
  dependsOn tasks.named('compileJava9Java')
}

tasks.register('sourcesJar', Jar) {
  from sourceSets.main.allJava
  from sourceSets.java9.allJava
  archiveBaseName = libraryName
  archiveClassifier = "sources"
  archiveVersion = component_version
}

tasks.withType(Javadoc).configureEach {
  // Allow javadoc to access internal sun.nio.ch package used by BufferWriter8
  options.addStringOption('-add-exports', 'java.base/sun.nio.ch=ALL-UNNAMED')
}

tasks.register('javadocJar', Jar) {
  dependsOn javadoc
  archiveBaseName = libraryName
  archiveClassifier = 'javadoc'
  archiveVersion = component_version
  from javadoc.destinationDir
}



tasks.register('scanBuild', Exec) {
  workingDir "${projectDir}/src/test/make"
  commandLine 'scan-build'
  args "-o", "${projectDir}/build/reports/scan-build",
    "--force-analyze-debug-code",
    "--use-analyzer", "/usr/bin/clang++",
    "make", "-j4", "all"
}

tasks.withType(Test) {
  onlyIf {
    !project.hasProperty('skip-tests')
  }
  def javaHome = System.getenv("JAVA_TEST_HOME")
  if (javaHome == null) {
    javaHome = System.getenv("JAVA_HOME")
  }
  executable = file("${javaHome}/bin/java")
  javaLauncher.set(javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(11)
  })
}

// relink the tasks when all are created
gradle.projectsEvaluated {
  buildConfigNames().each {
    def compileTask = tasks.findByName("compileLib${it.capitalize()}")
    def linkTask = tasks.findByName("linkLib${it.capitalize()}")
    if (linkTask != null) {
      if (it != 'release') {
        def copyTask = tasks.findByName("copy${it.capitalize()}Libs")
        if (copyTask != null) {
          copyTask.dependsOn linkTask
        }
      }
    }
    def javadocTask = tasks.findByName("javadoc")
    def copyReleaseLibs = tasks.findByName("copyReleaseLibs")
    if (javadocTask != null && copyReleaseLibs != null) {
      javadocTask.dependsOn copyReleaseLibs
    }
  }
}

artifacts {
  // create artifacts for all configures build config names
  buildConfigNames().each {
    def task = tasks.named("assemble${it.capitalize()}Jar")
    artifacts.add('assembled', task)
    artifacts.add(it, task)
  }
}

publishing {
  publications {
    assembled(MavenPublication) { publication ->
      buildConfigNames().each {
        publication.artifact tasks.named("assemble${it.capitalize()}Jar")
      }
      publication.artifact sourcesJar
      publication.artifact javadocJar

      publication.groupId = 'com.datadoghq'
      publication.artifactId = 'ddprof'
    }
  }
}

tasks.withType(GenerateMavenPom).configureEach {
  doFirst {
    MavenPom pom = it.pom
    pom.name = project.name
    pom.description = "${project.description} (${component_version})"
    pom.packaging = "jar"
    pom.url = "https://github.com/datadog/java-profiler"
    pom.licenses {
      license {
        name = "The Apache Software License, Version 2.0"
        url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
        distribution = "repo"
      }
    }
    pom.scm {
      connection = "scm:https://datadog@github.com/datadog/java-profiler"
      developerConnection = "scm:git@github.com:datadog/java-profiler"
      url = "https://github.com/datadog/java-profiler"
    }
    pom.developers {
      developer {
        id = "datadog"
        name = "Datadog"
      }
    }
  }
}

signing {
  useInMemoryPgpKeys(System.getenv("GPG_PRIVATE_KEY"), System.getenv("GPG_PASSWORD"))
  sign publishing.publications.assembled
}

tasks.withType(Sign).configureEach {
  // Only sign in Gitlab CI
  onlyIf { isGitlabCI || (System.getenv("GPG_PRIVATE_KEY") != null && System.getenv("GPG_PASSWORD") != null) }
}

/**
 * State assertions below...
 */

gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
  if (taskGraph.hasTask(publish) || taskGraph.hasTask("publishToSonatype")) {
    assert project.findProperty("removeJarVersionNumbers") != true
    if (taskGraph.hasTask("publishToSonatype")) {
      assert System.getenv("SONATYPE_USERNAME") != null
      assert System.getenv("SONATYPE_PASSWORD") != null
      if (isCI) {
        assert System.getenv("GPG_PRIVATE_KEY") != null
        assert System.getenv("GPG_PASSWORD") != null
      }
    }
  }
}

afterEvaluate {
  assert description: "Project $project.path is published, must have a description"
}

// we are publishing very customized artifacts - we are attaching the native library to the resulting JAR artifact
tasks.withType(AbstractPublishToMaven).configureEach {
  if (it.name.contains('AssembledPublication')) {
    it.dependsOn assembleReleaseJar
  }
  rootProject.subprojects {
    mustRunAfter tasks.matching { it instanceof VerificationTask }
  }
}

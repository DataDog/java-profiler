plugins {
    id 'cpp-library'
    id 'java'
    id 'maven-publish'
    id 'signing'

    id 'com.github.ben-manes.versions' version '0.27.0'
    id "com.diffplug.spotless" version "6.11.0"
}

def libraryName = "ddprof"

description = "Datadog Java Profiler Library"

def component_version = project.hasProperty("ddprof_version") ? project.ddprof_version : project.version

// this feels weird but it is the only way invoking `./gradlew :ddprof-lib:*` tasks will work
if (rootDir.toString().endsWith("ddprof-lib")) {
    apply from: rootProject.file('../common.gradle')
}

def libraryTargetPath() {
    return "${projectDir}/build/classes/java/main/META-INF/native-libs/${osIdentifier()}-${archIdentifier()}${isMusl() ? '-musl' : ''}"
}

def librarySourcePath(boolean debug = false) {
    def osarchext = ""
    if (osIdentifier() == 'linux' && archIdentifier() != 'x64') {
        // when built on aarch64 the location the library is built in is 'x86-64' ¯\_(ツ)_/¯
        osarchext = "x86-64"
    } else if (osIdentifier() == 'macos') {
        osarchext = archIdentifier() == 'x64' ? 'x86-64' : 'aarch64'
    }
    def libsDir = debug ? "debug" : "release"
    def qualifier = debug ? "" : "stripped"
    return "${projectDir}/build/lib/main/${libsDir}/${osIdentifier()}/${osarchext}/${qualifier}/libjavaProfiler.${osIdentifier() == 'macos' ? 'dylib' : 'so'}"
}

ext {
    libraryTargetPath = this.&libraryTargetPath
    librarySourcePath = this.&librarySourcePath
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

def isGitlabCI = System.getenv("GITLAB_CI") != null

// configure the compiler here
tasks.withType(CppCompile).configureEach {
    onlyIf {
        !project.hasProperty('skip-native')
    }
    def taskIncludes = ["${javaHome()}/include"]
    def taskArgs = ["-fno-omit-frame-pointer", "-momit-leaf-frame-pointer", "-fvisibility=hidden",
    "-fdata-sections", "-ffunction-sections", "-std=c++11", "-DPROFILER_VERSION=\"${version}\""]

    if (os().isMacOsX()) {
        taskIncludes.add "${javaHome()}/include/darwin"
        taskArgs.addAll(["-D_XOPEN_SOURCE", "-D_DARWIN_C_SOURCE"])
    } else if (os().isLinux()) {
        taskIncludes.add "${javaHome()}/include/linux"
        if (isMusl()) {
            taskArgs.add '-D__musl__'
        }
    }

    if (it.name.contains('Debug')) {
        taskArgs.addAll(["-DDEBUG", "-DCOUNTERS"])
    } else {
        taskArgs.add("-DNDEBUG")
    }

    // TODO for Clang we would use scan-build utility instead but it needs to be installed first
    
    taskIncludes.add "${projectDir}/../malloc-shim/src/main/public"

    includes {
        taskIncludes
    }

    compilerArgs.addAll(taskArgs)

}

// configure linker
tasks.withType(LinkSharedLibrary) {
    onlyIf {
        !project.hasProperty('skip-native')
    }
    linkerArgs.addAll(["-ldl", "-lpthread", "-lm"])
    if (os().isLinux()) {
        linkerArgs.addAll(["-Wl,-z,defs", "-Wl,-z,nodelete", "-lrt", "-static-libstdc++", "-static-libgcc",
        "-Wl,--exclude-libs,ALL", "-Wl,--gc-sections"])
    }
    linkerArgs.add '-v'
}

tasks.withType(StripSymbols) {
    onlyIf {
        !project.hasProperty('skip-native')
    }
}

library {
    baseName = "javaProfiler"
    source.from file('src/main/cpp')
    privateHeaders.from file('src/main/cpp')

    // aarch64 support is still incubating
    // for the time being an aarch64 linux machine will match 'machines.linux.x86_64'
    targetMachines = [machines.macOS, machines.linux.x86_64]
    linkage = [Linkage.SHARED]
}


dependencies {
    if (os().isLinux()) {
        // the malloc shim works only on linux
        project(':malloc-shim')
    }
}

// the bridge between the gradle build and gtests
// the gradle gtest plugin(s) are quite unusable at this moment - using a shell script seems to be the only sane option
task cppTest(type: Exec) {
    onlyIf {
        !project.hasProperty('skip-tests')
    }
    workingDir "$projectDir"
    commandLine './test.sh'

    dependsOn assemble
}

task copyLibs(type: Copy) {
    dependsOn cppTest
    if (!project.hasProperty("with-libs")) {
        from file(librarySourcePath())
        into file(libraryTargetPath())
    }
}

task copyDebugLibs(type: Copy) {
    // This must depend on copyLibs as Gradle detects that this task is using the same target path
    // and keeps on complaining about undeclared inputs
    dependsOn copyLibs

    from file(librarySourcePath(true))
    into file(libraryTargetPath())
}

// Allow specifying the external location for the native libraries
// The libraries should be properly sorted into subfolders corresponding to the `libraryTargetPath` value for each
// os/arch/libc combination
task copyExternalLibs(type: Copy) {
    if (project.hasProperty("with-libs")) {
        from(project.getProperty("with-libs")) {
            include "**/*.so"
            include "**/*.dylib"
        }
        into "${projectDir}/build/classes/java/main/META-INF/native-libs"
    }
}

jar.dependsOn copyExternalLibs

task sourcesJar(type: Jar) {
    from sourceSets.main.allJava
    archiveBaseName = libraryName
    archiveClassifier = "sources"
    archiveVersion = component_version
}

task javadocJar(type: Jar) {
    dependsOn javadoc
    archiveBaseName = libraryName
    archiveClassifier = 'javadoc'
    archiveVersion = component_version
    from javadoc.destinationDir
}

javadoc.dependsOn copyLibs

task assembleJar(type: Jar) {
    dependsOn copyExternalLibs
    if (!project.hasProperty('skip-native')) {
        dependsOn copyLibs
    }
    archiveBaseName = libraryName
    archiveClassifier = ""
    archiveVersion = component_version
    from sourceSets.main.output.classesDirs
}

task assembleDebugJar(type: Jar) {
    if (!project.hasProperty('skip-native')) {
        dependsOn copyDebugLibs
    }
    archiveBaseName = libraryName
    archiveClassifier = "debug"
    archiveVersion = component_version
    from sourceSets.main.output.classesDirs
}

task scanBuild(type: Exec) {
    workingDir "${projectDir}/src/test/make"
    commandLine 'scan-build'
    args "-o", "${projectDir}/build/reports/scan-build",
        "--force-analyze-debug-code",
        "--use-analyzer", "/usr/bin/clang++",
        "make", "-j4",  "clean", "all"
}

test {
    onlyIf {
        !project.hasProperty('skip-tests')
    }
    useJUnitPlatform()
}

tasks.withType(Test) {
    onlyIf {
        !project.hasProperty('skip-tests')
    }
    def javaHome = System.getenv("JAVA_TEST_HOME")
    if (javaHome == null) {
        javaHome = System.getenv("JAVA_HOME")
    }
    executable = new File("${javaHome}", 'bin/java')
}

configurations {
    assembled {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation
    }
    debug {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation
    }
}

artifacts {
    assembled(assembleJar)
    assembled(assembleDebugJar)
    assembled(sourcesJar)
    assembled(javadocJar)
    assembled(assembleDebugJar)
    debug(assembleDebugJar)
}

publishing {
    publications {
        assembled(MavenPublication) { publication ->
            publication.artifact project.tasks.assembleJar
            publication.artifact project.tasks.assembleDebugJar
            publication.artifact sourcesJar
            publication.artifact javadocJar

            publication.groupId = 'com.datadoghq'
            publication.artifactId = 'ddprof'
        }
    }
}

tasks.withType(GenerateMavenPom).configureEach {
    doFirst {
        MavenPom pom = it.pom
        pom.name = project.name
        pom.description = "${project.description} (${component_version})"
        pom.packaging = "jar"
        pom.url = "https://github.com/datadog/java-profiler"
        pom.licenses {
            license {
                name = "The Apache Software License, Version 2.0"
                url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
                distribution = "repo"
            }
        }
        pom.scm {
            connection = "scm:https://datadog@github.com/datadog/java-profiler"
            developerConnection = "scm:git@github.com:datadog/java-profiler"
            url = "https://github.com/datadog/java-profiler"
        }
        pom.developers {
            developer {
                id = "datadog"
                name = "Datadog"
            }
        }
    }
}

signing {
    useInMemoryPgpKeys(System.getenv("GPG_PRIVATE_KEY"), System.getenv("GPG_PASSWORD"))
    sign publishing.publications.assembled
}

tasks.withType(Sign).configureEach {
    // Only sign in Gitlab CI
    onlyIf { isGitlabCI || (System.getenv("GPG_PRIVATE_KEY") != null && System.getenv("GPG_PASSWORD") != null) }
}

/**
 * State assertions below...
 */

gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
    if (taskGraph.hasTask(publish) || taskGraph.hasTask("publishToSonatype")) {
        assert project.findProperty("removeJarVersionNumbers") != true
        if (taskGraph.hasTask("publishToSonatype")) {
            assert System.getenv("SONATYPE_USERNAME") != null
            assert System.getenv("SONATYPE_PASSWORD") != null
            if (isCI) {
                assert System.getenv("GPG_PRIVATE_KEY") != null
                assert System.getenv("GPG_PASSWORD") != null
            }
        }
    }
}

afterEvaluate {
    assert description: "Project $project.path is published, must have a description"
}

// we are publishing very customized artifacts - we are attaching the native library to the resulting JAR artifact
tasks.withType(AbstractPublishToMaven).configureEach {
    if (it.name.contains('AssembledPublication')) {
        it.dependsOn assembleJar
    }
    rootProject.subprojects {
        mustRunAfter tasks.matching { it instanceof VerificationTask }
    }
}
